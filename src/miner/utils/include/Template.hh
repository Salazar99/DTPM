

#pragma once

#include <algorithm>
#include <cstdarg>
#include <deque>
#include <mutex>
#include <numeric>
#include <regex>
#include <spot/tl/formula.hh>
#include <string>
#include <thread>
#include <unordered_map>

#include "Automaton.hh"
#include "BDTAnd.hh"
#include "BDTNCReps.hh"
#include "BDTNext.hh"
#include "BDTNextAnd.hh"
#include "EdgeProposition.hh"
#include "Hstring.hh"
#include "Location.hh"
#include "PermGenerator.hh"
#include "Semaphore.hh"
#include "Trace.hh"
#include "Trinary.hh"
#include "exp.hh"

// spotLTL
#include "spot/tl/parse.hh"
#include "spot/tl/print.hh"
#include "spot/twa/bddprint.hh"
#include "spot/twaalgos/hoa.hh"
#include "spot/twaalgos/translate.hh"

namespace harm {

/*! \class Template
    \brief Class representing an assertion template, the template can be
   instantiated by loading boolean propositions
*/
class Template {

public:
  /** \brief Constructor
   * \param templateFormula representation of a template as a PSL formula
   * \param max_length length of the trace
   */
  Template(Hstring &templateFormula, harm::Trace *trace, BDTLimits limits);

  Template(const Template &original);

  ~Template();

  /** \brief loads propositions to instantiate the complete
   * \param props list of propositions to be used to instantiate the template
   * \param where location in which insert the propositions ( antecedent,
   * consequent or both)
   */
  void loadPropositions(std::vector<Proposition *> &props,
                        harm::Location where);
  /** \brief evaluates the assertion generated by loading the propositions in
   * the template
   * \param time trace instant on which evaluate the assertion
   */
  Trinary evaluate(size_t time);
  Trinary evaluateOffset(size_t time);
  Trinary evaluate_ant(size_t time);
  Trinary evaluateAntNoChache(size_t time);
  Trinary evaluate_con(size_t time);
  int getDepth(Automaton *aut);

  // @brief in the case of partially instantiated permutations with template
  //        .. && .. it is necessary to re-evaluate the assertion
  void setCacheAntFalse();
  void setCacheConFalse();
  // get & set

  /** \brief returns the template insantiated with the propositions
   * Warning: this method can only be called if the template is instantiated!
   */
  std::string getAssertion();
  std::string getColoredAssertion();

  std::string getTemplate();
  Hstring getTemplateFormula();
  std::string getColoredTemplate();

  /** \brief returns a spot-compatible string representation of the template
   */
  std::string getSpotFormula();

  BDTOperator *getBDT();
  std::map<std::string, Proposition **> &get_aphToProp();
  std::map<std::string, Proposition **> &get_cphToProp();
  std::map<std::string, Proposition **> &get_acphToProp();

  size_t getNumPlaceholders(harm::Location where);
  size_t getNumPlaceholders();

  /** \brief  generates a sequence of permutations for the current template,
   * each permutation is a set of propositions to be used to instantiate the
   * template
   * \param antP propositions for the antecedent
   * \param conP propositions for the consequent
   * \param antConP propositions for placeholders that are both in the
   * antecedent and the consequent
   */
  void genPermutations(const std::vector<Proposition *> &antP,
                       const std::vector<Proposition *> &conP,
                       const std::vector<Proposition *> &antConP);

  /** \brief loads the next permutation in the template. This method must be
   * called after genPermutations.
   */
  bool nextPerm();
  void loadPerm(size_t n);
  std::vector<Proposition *> getLoadedPropositions();
  void
  getPlaceholdersDepth(spot::formula f,
                       std::vector<std::pair<std::string, size_t>> &phToDepth);
  std::vector<std::pair<Proposition *, size_t>>
  getLoadedPropositionsWithDepth();
  std::vector<std::pair<Proposition *, size_t>>
  getLoadedPropositionsWithDepthAnt();
  std::vector<std::pair<Proposition *, size_t>>
  getLoadedPropositionsWithDepthCon();
  /** \brief get number of permutations generated */
  size_t nPermsGenerated() const;

  bool assHoldsOnTrace(harm::Location update);
  bool assHoldsOnTraceOffset(harm::Location update);
  bool isVacuous(harm::Location update);
  bool isVacuousOffset(harm::Location update);
  std::pair<size_t, size_t> partialContingency();
  bool quadFaster();

private:
  // set of technical methods, they implement the generation and the evaluation
  // of the template

  /** \brief initialises the template and builds all the necessary parts. To be
   * called only in the constructor!
   */
  void build();

  /** \brief builds a custom automaton from a spotLTL automaton
   */
  Automaton *buildAutomaton(spot::twa_graph_ptr &automata);

  /** \brief converts a spot LTL formula to a custom proposition
   */
  EdgeProposition *edgeToProposition(const spot::formula &f);

  /** \brief evaluates the formula implemented by the custom automaton
   */
  Trinary evalAutomaton(size_t time, Automaton *root) const;
  Trinary evalAutomatonDyShift(size_t time, Automaton *root, size_t &dShift);

  std::pair<size_t, size_t> partialContingency(Automaton *aut);
  void maxDepth(int &max, Automaton::Node *cn, size_t currDepth,
                std::unordered_set<size_t> &marked);

public:
  struct Range {
    Range() {}
    Range(size_t start, size_t length) : _start(start), _length(length) {
      // not todo
    }
    size_t _start;
    size_t _length;
  };

  void linearEval(harm::Location what);

  template <bool Dynamic>
  inline void evalWithCut(Automaton *aut, Trinary *cachedValues);

  template <bool Dynamic>
  void linearEval(Automaton *aut, Trinary *cachedValues, Range traceRange,
                  Range threadsRange, ProtectedQueueNotify<Range> &threadsPool);

  template <bool Dynamic>
  inline void runLinearEval(Automaton *aut, Trinary *cachedValues,
                            Range &traceRange, const Range &threadsRange,
                            size_t nThread = 0);

  template <bool Dynamic>
  void joinData(Trinary *cachedValues, Range traceRange,
                const Range &threadsRange);

  void quadraticEval(harm::Location what);
  void quadraticEval(Automaton *aut, Trinary *cachedValues);
  void quadraticEvalDynamic(Automaton *aut, Trinary *cachedValues);
  void fillContingency(size_t (&ct)[3][3], bool offset);
  void setL1Threads(size_t n);
  size_t getL1Threads();

  void setBDTLimits(const BDTLimits &l);
  bool saveOffset();
  bool isFullyInstantiated();
  void printContingency();
  std::unordered_map<std::string, size_t> findCauseOfFailure();
  std::string findCauseOfFailure(size_t time);

  std::string findCauseInEdgeProposition(EdgeProposition *ep, size_t time,
                                         bool goal, bool expPlaceholders);

  std::string findCauseInProposition(Proposition *ep, size_t time, bool goal);
  std::shared_ptr<spot::twa_graph>
  generateDeterministicSpotAutomaton(spot::formula &formula);

  void check();

  Proposition *getPropByToken(const std::string &token);
  Automaton *buildDiamondAutomaton(bool conNegated = 0);
  Automaton *getAntecedentAutomaton();

  size_t gatherInterestingValue(size_t time, int depth, int width);

  void subPropInAssertion(Proposition *original, Proposition *newProp);

  // printers
  std::string printAutomatons();
  std::string printAutomaton(Automaton *aut);

private:
  std::mutex _l1Guard;

  /// PSL representation of the template
  Hstring _templateFormula;

  Hstring _buildTemplateFormula;

  /// used to generate the permutations
  PermGenerator _pg;

  /*utility fields to link the placeholders with the instantiated propositions,
   * note that if the placeholder is not instantiated, then the proposition
   * points to a nullptr
   */
  /// link of all placeholders to all instantiated propositions
  std::unordered_map<std::string, Proposition **> _tokenToProp;
  /// link of all user instantiated placeholders to their respective
  /// propositions
  std::unordered_map<std::string, Proposition **> _iToProp;
  /// link of all bdt operators to their respective propositions
  std::pair<std::string, BDTOperator *> _bdtOp = {"", nullptr};

  //_aphToProp + _cphToProp + _acphToProp == _phToProp
  std::map<std::string, Proposition **> _aphToProp;
  std::map<std::string, Proposition **> _cphToProp;
  std::map<std::string, Proposition **> _acphToProp;

  /* current proposition domains:
    the generator of permutations will use the following propositions to
    generate the permutations
    */
  std::vector<Proposition *> _aProps;
  std::vector<Proposition *> _cProps;
  std::vector<Proposition *> _acProps;

  Automaton *_con;
  Automaton *_ant;

public:
  // length of the trace
  size_t _max_length;
  harm::Trace *_trace;

private:
  /*
   the constant temporal shift that must be applied to evaluate the consequent
   ex. if the template is Ant => Con the constant shift will be equal to 1
       if the template is Ant -> Con the constant shift will be equal to 0
   */
  size_t _constShift;

  // if true, we must apply a dynamic shift before evaluating the consequent
  bool _applyDynamicShift;

  // if true, the current values stored in the cash for the decedent/consequent
  // are valid
  bool _antInCache = false;
  bool _conInCache = false;

public:
  size_t *_dynamicShiftCachedValues = nullptr;
  size_t _permShift = 0;

private:
  BDTLimits _limits;

  // cached values are used to avoid recalculating each time the truth values of
  // the current assertion
  Trinary *_antCachedValues = nullptr;
  Trinary *_conCachedValues = nullptr;

  Trinary **_cachedValuesP = nullptr;

  size_t **_cachedDynShiftsP = nullptr;

  /// index to the current permutatian, -1 if no permutations are generated
public:
  int _permIndex = -1;
  bool _check = 0;

private:
  int _antDepth = 0;
  int _conDepth = 0;

  size_t _availThreads = 1;

  friend BDTNext;
  friend BDTNCReps;
  friend BDTNextAnd;
  friend BDTAnd;
};
} // namespace harm
